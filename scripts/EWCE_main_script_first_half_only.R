#This is a function used by this EWCE pipeline to generate cell-type expression data for the genes on the given gene list
#results       = the output from ewce_expression_data() function
#signif_res    = subset of those results with p <= 0.05 with a Bonferroni correction
#sct_data      = cell type data object produced by EWCE package
#mouse.hits    = MGI gene names for gene list
#combinedGenes = MGI gene names for gene list and background genes
#annotLevel    = what level of cell type annotation to use from the cell type data object
# nReps        = bootstrap reps

########################################################################
#This is code copied from https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NathanSkene_EWCE_blob_master_R_generate.bootstrap.plots.for.transcriptome.r&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=tYjva-maOWYw2AoI8eh9I-u9HURMPxWRrqwho_snpQo&e= 
get_exp_data_for_bootstrapped_genes <- function(results,signif_res,sct_data,mouse.hits,combinedGenes,annotLevel,nReps = reps){
  exp_mats = list()
  for(cc in signif_res){
    exp_mats[[cc]] = matrix(0,nrow=nReps,ncol=length(mouse.hits))
    rownames(exp_mats[[cc]]) = sprintf("Rep%s",1:nReps)
  }
  for(s in 1:nReps){
    bootstrap_set = sample(combinedGenes,length(mouse.hits))
    ValidGenes = rownames(sct_data[[annotLevel]]$specificity)[rownames(sct_data[[annotLevel]]$specificity) %in% bootstrap_set]
    
    expD = sct_data[[annotLevel]]$specificity[ValidGenes,]
    
    for(cc in signif_res){
      exp_mats[[cc]][s,] = sort(expD[,cc])
    }
  }
  return(exp_mats)
}
########################################################################
  
  

#This is a function used to generate individual gene specificity distributions & values
#The "distributions" are the results of random sampling
#The "values" are the percent of total gene expression in that cell type
#dat        = data.frame(boot=mean_boot_exp,hit=hit_exp,Gnames=hit_exp_names)
#exp_mats   = output of get_exp_data_for_bootstrapped_genes() function
#cc         = count
#hit_exp    = expression data of gene list genes in cell type data object
########################################################################
#This is code copied with some editing from https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NathanSkene_EWCE_blob_master_R_generate.bootstrap.plots.for.transcriptome.r&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=tYjva-maOWYw2AoI8eh9I-u9HURMPxWRrqwho_snpQo&e= 
  bootstrap_distributions_and_actVals <- function(dat,exp_mats,cc,hit_exp){

    datOrdered = data.frame(GSym=rownames(dat),Pos=1:dim(dat)[1])
    
    # - Arrange the data frame for plotting
    melt_boot = reshape2::melt(exp_mats[[cc]])
    colnames(melt_boot) = c("Rep","Pos","Exp")
    melt_boot$Exp = melt_boot$Exp*100
    melt_boot = merge(melt_boot,datOrdered,by="Pos")
    melt_boot$GSym = factor(as.character(melt_boot$GSym),levels=as.character(datOrdered$GSym))
    
    # - Prepare the values of the list genes to be plotted as red dots
    actVals = data.frame(Pos=as.factor(1:length(hit_exp)),vals=hit_exp*100)
    actVals = merge(actVals,datOrdered,by="Pos")
    actVals$GSym = factor(as.character(actVals$GSym),levels=as.character(datOrdered$GSym))
    
    # - Determine whether changes are significant
    p = rep(1,max(melt_boot$Pos))
    
    for(i in 1:max(melt_boot$Pos)){
      p[i] = sum(actVals[actVals$Pos==i,"vals"]<melt_boot[melt_boot$Pos==i,"Exp"])/length(melt_boot[melt_boot$Pos==i,"Exp"])
    }
    
    ast = rep("*",max(melt_boot$Pos))
    ast[p>0.05] = ""
    actVals = cbind(actVals[order(actVals$Pos),],p,ast)
    
    distributions_and_values <- list(melt_boot, actVals)
    names(distributions_and_values) <- c("distributions","values")
    return(distributions_and_values)
  }
########################################################################   
    
    
#This a function that runs as a shell around the EWCE package to generate EWCE output data with minimal user input
#tissue_data = the bulk rnaSeq data that you want to be tested. Should be in the form of a dataframe with the differential gene expression already calculated
#sort_by_col = the column in tissue data to measure gene expression (I have used the t statistic)
#hgnc_names_col = HGNC gene names column
#cell_type_data = cell type data object generated by EWCE package 
#annotation_levels = number of annotation levels in the cell_type_data object you are using
#tissue_data_species = "mouse" or "human"
#cell_type_data_species = "mouse" or "human"
#gene_threshold = cutoff for number of genes to include on gene list
#bootstrap_reps = number of random sampling events
#output_name = what to call the output. 
########################################################################
  #This is a function that Jake Herb wrote in July of 2020
    analyze_using_EWCE <- function(tissue_data, sort_by_col, hgnc_names_col, cell_type_data, annotation_levels, 
                                   tissue_data_species, cell_type_data_species, gene_threshold, bootstrap_reps, output_name){	
      
      #generating a list of tissue names included in the transcriptomic data
      tissue_list <- names(tissue_data)
      number_of_tissues <- length(tissue_list)
      all_levels_analysis <- list(1:annotation_levels)
      
      #iterating through the annotation levels
      #generating a currently-empty list to fill later
      #if the list is not finished correctly, you will see values that say not_finished_yet
      for(count in list(1:annotation_levels)){
        all_levels_analysis[count] <- "not_finished_yet_ERROR"
        names(all_levels_analysis) <- sprintf("level%i_output",count)
      }
      
      #generating an empty list for the tissue output data to be filled later
      tissue_output <- rep(list(all_levels_analysis),times = number_of_tissues)
      names(tissue_output) <- tissue_list
      
      #generating files for the EWCE plots. One file for each level of annotation
      for(count in c(1:annotation_levels)){
        if(!file.exists(sprintf("level%i_plots",count))){
          dir.create(file.path(getwd(), sprintf("level%i_plots",count)))
        }
      }
      
      #nested for loop to repeat analysis for every annotation level at every tissue type
      #THIS CODE RUNS THE EWCE_EXPRESSION_DATA FUNCTION
      #certain columns in the transcriptomic data are re labeled so that EWCE has no trouble identifying them. 
      for (i in c(1:number_of_tissues)){
        tissue_df <- as.data.frame(tissue_data[i])
        names(tissue_df)[hgnc_names_col] <- "HGNC.symbol"
        names(tissue_df)[sort_by_col] <- "t"
        for(j in c(1:annotation_levels)){
          tissue_output[[i]][j] <- ewce_expression_data(sct_data = cell_type_data, tt = tissue_df, sortBy = "t", annotLevel = j, 
                                                        ttSpecies = tissue_data_species, sctSpecies = cell_type_data_species, thresh = gene_threshold)
          
        }
      }
      
      #setting figure dimensions based on number of x-axis categories
      ewce_expression_output <- tissue_output
      for (i in c(1:number_of_tissues)){
        for(j in c(1:annotation_levels)){
          joint_results <- as.data.frame(ewce_expression_output[[i]][j])
          colnames(joint_results) <- c("CellType","annotLevel","p","fold_change","sd_from_mean","Direction")
          ewce_plot <- ewce.plot(joint_results)$plain
          print(ewce_plot)
          
          if(ncol(cell_type_data[[j]][[2]]) %in% c(1:10)){
            height = 4
            width = 8
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(11:20)){
            height = 8
            width = 16
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(21:30)){
            height = 10
            width = 20
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(31:40)){
            height = 8
            width = 42
          } else{
            height = 8
            width = 42
          }
          
          #saving EWCE plots
          ggsave(filename = sprintf("tissue%sannotationLevel%ibootstrapREPs%s_GeneThresholdTopandBottom%s_plot.pdf",tissue_list[i],j,bootstrap_reps,gene_threshold, sep="_"), 
                 plot = ewce_plot, device = "pdf",path=sprintf("level%i_plots",j), height = height, width = width)
          
          #this is probably not useful. But you can run this code too if you like. it makes a ton more plots
          #####################################################################################
          ###REMOVE THESE HASH MARKS IF YOU WANT BOOTSTRAP PLOTS. TAKES A LONG TIME TO COMPUTE
          #temp_output <- ewce_expression_data(sct_data = cell_type_data, tt = tissue_df, sortBy = "t", annotLevel = j, ttSpecies = tissue_data_species, sctSpecies = cell_type_data_species, thresh = gene_threshold)
          #generate.bootstrap.plots.for.transcriptome(sct_data=cell_type_data, tt=tissue_df, annotLevel=j, full_results = temp_output, listFileName = paste(tissue_list[i],sprintf("bootstrap_level%i",j,sep="_")), reps=bootstrap_reps, ttSpecies=tissue_data_species,sctSpecies=cell_type_data_species)
          #####################################################################################
        }
      }
      
      save(ewce_expression_output, file= output_name)
      return(ewce_expression_output)
    }
      #end_of_function
########################################################################