#This is a function used by this EWCE pipeline to generate cell-type expression data for the genes on the given gene list
#results       = the output from ewce_expression_data() function
#signif_res    = subset of those results with p <= 0.05 with a Bonferroni correction
#sct_data      = cell type data object produced by EWCE package
#mouse.hits    = MGI gene names for gene list
#combinedGenes = MGI gene names for gene list and background genes
#annotLevel    = what level of cell type annotation to use from the cell type data object
# nReps        = bootstrap reps

########################################################################
#This is code copied from https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NathanSkene_EWCE_blob_master_R_generate.bootstrap.plots.for.transcriptome.r&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=tYjva-maOWYw2AoI8eh9I-u9HURMPxWRrqwho_snpQo&e= 
get_exp_data_for_bootstrapped_genes <- function(results,signif_res,sct_data,mouse.hits,combinedGenes,annotLevel,nReps = reps){
  exp_mats = list()
  for(cc in signif_res){
    exp_mats[[cc]] = matrix(0,nrow=nReps,ncol=length(mouse.hits))
    rownames(exp_mats[[cc]]) = sprintf("Rep%s",1:nReps)
  }
  for(s in 1:nReps){
    bootstrap_set = sample(combinedGenes,length(mouse.hits))
    ValidGenes = rownames(sct_data[[annotLevel]]$specificity)[rownames(sct_data[[annotLevel]]$specificity) %in% bootstrap_set]
    
    expD = sct_data[[annotLevel]]$specificity[ValidGenes,]
    
    for(cc in signif_res){
      exp_mats[[cc]][s,] = sort(expD[,cc])
    }
  }
  return(exp_mats)
}
########################################################################
  
  

#This is a function used to generate individual gene specificity distributions & values
#The "distributions" are the results of random sampling
#The "values" are the percent of total gene expression in that cell type
#dat        = data.frame(boot=mean_boot_exp,hit=hit_exp,Gnames=hit_exp_names)
#exp_mats   = output of get_exp_data_for_bootstrapped_genes() function
#cc         = count
#hit_exp    = expression data of gene list genes in cell type data object
########################################################################
#This is code copied with some editing from https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NathanSkene_EWCE_blob_master_R_generate.bootstrap.plots.for.transcriptome.r&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=tYjva-maOWYw2AoI8eh9I-u9HURMPxWRrqwho_snpQo&e= 
  bootstrap_distributions_and_actVals <- function(dat,exp_mats,cc,hit_exp){

    datOrdered = data.frame(GSym=rownames(dat),Pos=1:dim(dat)[1])
    
    # - Arrange the data frame for plotting
    melt_boot = reshape2::melt(exp_mats[[cc]])
    colnames(melt_boot) = c("Rep","Pos","Exp")
    melt_boot$Exp = melt_boot$Exp*100
    melt_boot = merge(melt_boot,datOrdered,by="Pos")
    melt_boot$GSym = factor(as.character(melt_boot$GSym),levels=as.character(datOrdered$GSym))
    
    # - Prepare the values of the list genes to be plotted as red dots
    actVals = data.frame(Pos=as.factor(1:length(hit_exp)),vals=hit_exp*100)
    actVals = merge(actVals,datOrdered,by="Pos")
    actVals$GSym = factor(as.character(actVals$GSym),levels=as.character(datOrdered$GSym))
    
    # - Determine whether changes are significant
    p = rep(1,max(melt_boot$Pos))
    
    for(i in 1:max(melt_boot$Pos)){
      p[i] = sum(actVals[actVals$Pos==i,"vals"]<melt_boot[melt_boot$Pos==i,"Exp"])/length(melt_boot[melt_boot$Pos==i,"Exp"])
    }
    
    ast = rep("*",max(melt_boot$Pos))
    ast[p>0.05] = ""
    actVals = cbind(actVals[order(actVals$Pos),],p,ast)
    
    distributions_and_values <- list(melt_boot, actVals)
    names(distributions_and_values) <- c("distributions","values")
    return(distributions_and_values)
  }
########################################################################   
    
    
#This a function that runs as a shell around the EWCE package to generate EWCE output data with minimal user input
#tissue_data = the bulk rnaSeq data that you want to be tested. Should be in the form of a dataframe with the differential gene expression already calculated
#sort_by_col = the column in tissue data to measure gene expression (I have used the t statistic)
#hgnc_names_col = HGNC gene names column
#cell_type_data = cell type data object generated by EWCE package 
#annotation_levels = number of annotation levels in the cell_type_data object you are using
#tissue_data_species = "mouse" or "human"
#cell_type_data_species = "mouse" or "human"
#gene_threshold = cutoff for number of genes to include on gene list
#bootstrap_reps = number of random sampling events
#output_name = what to call the output. 
########################################################################
  #This is a function that Jake Herb wrote in July of 2020
    analyze_using_EWCE <- function(tissue_data, sort_by_col, hgnc_names_col, cell_type_data, annotation_levels, 
                                   tissue_data_species, cell_type_data_species, gene_threshold, bootstrap_reps, output_name){	
      
      #generating a list of tissue names included in the transcriptomic data
      tissue_list <- names(tissue_data)
      number_of_tissues <- length(tissue_list)
      all_levels_analysis <- list(1:annotation_levels)
      
      #iterating through the annotation levels
      #generating a currently-empty list to fill later
      #if the list is not finished correctly, you will see values that say not_finished_yet
      for(count in list(1:annotation_levels)){
        all_levels_analysis[count] <- "not_finished_yet_ERROR"
        names(all_levels_analysis) <- sprintf("level%i_output",count)
      }
      
      #generating an empty list for the tissue output data to be filled later
      tissue_output <- rep(list(all_levels_analysis),times = number_of_tissues)
      names(tissue_output) <- tissue_list
      
      #generating files for the EWCE plots. One file for each level of annotation
      for(count in c(1:annotation_levels)){
        if(!file.exists(sprintf("level%i_plots",count))){
          dir.create(file.path(getwd(), sprintf("level%i_plots",count)))
        }
      }
      
      #nested for loop to repeat analysis for every annotation level at every tissue type
      #THIS CODE RUNS THE EWCE_EXPRESSION_DATA FUNCTION
      #certain columns in the transcriptomic data are re labeled so that EWCE has no trouble identifying them. 
      for (i in c(1:number_of_tissues)){
        tissue_df <- as.data.frame(tissue_data[i])
        names(tissue_df)[hgnc_names_col] <- "HGNC.symbol"
        names(tissue_df)[sort_by_col] <- "t"
        for(j in c(1:annotation_levels)){
          tissue_output[[i]][j] <- ewce_expression_data(sct_data = cell_type_data, tt = tissue_df, sortBy = "t", annotLevel = j, 
                                                        ttSpecies = tissue_data_species, sctSpecies = cell_type_data_species, thresh = gene_threshold)
          
        }
      }
      
      #setting figure dimensions based on number of x-axis categories
      ewce_expression_output <- tissue_output
      for (i in c(1:number_of_tissues)){
        for(j in c(1:annotation_levels)){
          joint_results <- as.data.frame(ewce_expression_output[[i]][j])
          colnames(joint_results) <- c("CellType","annotLevel","p","fold_change","sd_from_mean","Direction")
          ewce_plot <- ewce.plot(joint_results)$plain
          print(ewce_plot)
          
          if(ncol(cell_type_data[[j]][[2]]) %in% c(1:10)){
            height = 4
            width = 8
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(11:20)){
            height = 8
            width = 16
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(21:30)){
            height = 10
            width = 20
          } else if(ncol(cell_type_data[[j]][[2]]) %in% c(31:40)){
            height = 8
            width = 42
          } else{
            height = 8
            width = 42
          }
          
          #saving EWCE plots
          ggsave(filename = sprintf("tissue%sannotationLevel%ibootstrapREPs%s_GeneThresholdTopandBottom%s_plot.pdf",tissue_list[i],j,bootstrap_reps,gene_threshold, sep="_"), 
                 plot = ewce_plot, device = "pdf",path=sprintf("level%i_plots",j), height = height, width = width)
          
          #this is probably not useful. But you can run this code too if you like. it makes a ton more plots
          #####################################################################################
          ###REMOVE THESE HASH MARKS IF YOU WANT BOOTSTRAP PLOTS. TAKES A LONG TIME TO COMPUTE
          #temp_output <- ewce_expression_data(sct_data = cell_type_data, tt = tissue_df, sortBy = "t", annotLevel = j, ttSpecies = tissue_data_species, sctSpecies = cell_type_data_species, thresh = gene_threshold)
          #generate.bootstrap.plots.for.transcriptome(sct_data=cell_type_data, tt=tissue_df, annotLevel=j, full_results = temp_output, listFileName = paste(tissue_list[i],sprintf("bootstrap_level%i",j,sep="_")), reps=bootstrap_reps, ttSpecies=tissue_data_species,sctSpecies=cell_type_data_species)
          #####################################################################################
        }
      }
      
      ### TABLE CODE STARTS HERE ### This is code that provides more information about what individual genes are doing in the target gene list
      
      #generating an empty list to fill later
      #if it is not filled, you will see the message "no_significant_cell_type_enrichment"
      warning_list <- list("no_significant_cell_type_enrichment")
      
      #generating more empty lists to fill
      output_levels <- rep(list(warning_list), times = annotation_levels) #j
      names(output_levels) <- names(ewce_expression_output[[1]])
      output_tissues <- rep(list(output_levels), times = number_of_tissues) #i
      names(output_tissues) <- tissue_list
      boot_dist_and_vals <- output_tissues
      
      
      #iterating through every annotation level in every tissue
      for (i in c(1:number_of_tissues)){ ###Start of Tissue for loop
        for(j in c(1:annotation_levels)){ ###Start of Annotation for loop
          
          #start using the ewce expression output
          joint_results <- as.data.frame(ewce_expression_output[[i]][j])
          colnames(joint_results) <- c("CellType","annotLevel","p","fold_change","sd_from_mean","Direction")
          
          #the code that I borrowed from here used "tt" and variations such as "tt2" to point to the transcriptomic data. So i use that here too.
          tt2 = as.data.frame(tissue_data[i])
          names(tt2)[hgnc_names_col] <- "HGNC.symbol"
          names(tt2)[sort_by_col] <- "t"
          mouse_to_human_homologs <- EWCE::mouse_to_human_homologs
          m2h = unique(mouse_to_human_homologs[,c("HGNC.symbol","MGI.symbol")])
          tt2 = merge(tt2,m2h,by="HGNC.symbol")
          
          tt3 = tt2[order(tt2[,"t"]),]
          
          mouse.upreg.hits = unique(tt3[dim(tt3)[1]:(dim(tt3)[1] - gene_threshold), "MGI.symbol"])
          mouse.downreg.hits = unique(tt3[1:gene_threshold,"MGI.symbol"])
          https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  = unique(tt3$MGI.symbol)
          
          #generating empty lists to be filled in the next for loop
          output_signif_cell_types_up <- list("no_significant_up-enrichment_in_this_tissue_at_this_level")
          output_signif_cell_types_down <- list("no_significant_down-enrichment_in_this_tissue_at_this_level")
          
          for(dirS in c("Up","Down")){ ###Start of Direction for loop
            
            a = joint_results
            results = a[as.character(a$Direction)==dirS,]
            if(dirS=="Up"){tt3=tt3[order(tt3[,"t"],decreasing=TRUE),]}
            if(dirS=="Down"){tt3=tt3[order(tt3[,"t"],decreasing=FALSE),]}
            
            annotLevel = j
            mouse.hits = as.character(unique(tt3$MGI.symbol[1:gene_threshold]))
            mouse.hits = mouse.hits[mouse.hits %in% rownames(cell_type_data[[annotLevel]]$specificity)]
            
            https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  = as.character(unique(tt3$MGI.symbol))
            https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  = mouse.bg[!https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  %in% mouse.hits]
            https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  = mouse.bg[https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e=  %in% rownames(cell_type_data[[annotLevel]]$specificity)]
            
            combinedGenes = unique(c(mouse.hits, https://urldefense.proofpoint.com/v2/url?u=http-3A__mouse.bg&d=DwICAg&c=shNJtf5dKgNcPZ6Yh64b-A&r=bwmts2__cVwcBAFQqjvgnZCTFW2upB74SSUBWpbFWfM&m=7S5JpKoEdICnDQnIBnQ7fLaKQtCYb66nlcpRU_1NTJE&s=0GDXnIoiFvb_40TDutZOF--5s7bi8p_Y2M1_O50YWeY&e= ))
            
            signif_res = as.character(results$CellType)[results$p<0.05/length(colnames(cell_type_data[[j]][[2]]))]
            signif_res_length <- length(signif_res)
            hit.exp = cell_type_data[[j]]$specificity[mouse.hits,]
            
            exp_mats <- get_exp_data_for_bootstrapped_genes(results,signif_res,cell_type_data,mouse.hits,combinedGenes,annotLevel,nReps = bootstrap_reps)
            
            #for loop that builds the results. 
            k = 0
            for(cc in signif_res){ ###Start of significant result for loop
              
              if(length(signif_res > 0)){ ###Start of extended if statement
                k = k + 1

                mean_boot_exp = apply(exp_mats[[cc]],2,mean)
                hit_exp = sort(hit.exp[,cc])
                hit_exp_names = rownames(hit.exp)[order(hit.exp[,cc])]#names(hit_exp)
                dat = data.frame(boot=mean_boot_exp,hit=hit_exp,Gnames=hit_exp_names)

                if(dirS == "Up"){
                  up_bootstrap_distributions_and_actVals <- bootstrap_distributions_and_actVals(dat,exp_mats,cc,hit_exp)
                  output_signif_cell_types_up[k] <- list(up_bootstrap_distributions_and_actVals)
                }
                
                else if(dirS == "Down"){
                  down_bootstrap_distributions_and_actVals <- bootstrap_distributions_and_actVals(dat,exp_mats,cc,hit_exp)
                  output_signif_cell_types_down[k] <- list(down_bootstrap_distributions_and_actVals)
                }
              } ### End of extended if statement
              
              
              
              if(((k == signif_res_length) || k == 0) && (dirS == "Up")){
                names(output_signif_cell_types_up) <- signif_res
              }
              
              if(((k == signif_res_length) || k == 0) && (dirS == "Down")){
                names(output_signif_cell_types_down) <- signif_res
                combined_signif_cell_type_output <- list(output_signif_cell_types_up, output_signif_cell_types_down)
                names(combined_signif_cell_type_output) <- c("up_enriched","down_enriched")
                
                boot_dist_and_vals[[i]][[j]] <- combined_signif_cell_type_output
              }
              
            } ### End of significant result for loop 
          } ### End of Direction for loop
        } ### End of Annotation for loop
      } ### End of Tissue for loop
    
      ewce_final_results <- list(ewce_expression_output, boot_dist_and_vals)
      names(ewce_final_results) <- c("ewce_expression_output","bootstrapping_output")
      save(ewce_final_results, file= output_name)
      return(ewce_final_results)
    }
      #end_of_function
########################################################################